// Measures the cost of every possible combination of shape indices
// And chooses the

// TODO broken
//public static function optimalBruteForceOptimize(shapes:FlxTypedGroup<CircleSprite>):Void {
//	// Build map of shape->shape swapping improvements
//	var results = new ObjectMap<CircleSprite, Array<{ index:Int, improvement:Float }>>();
//
//	// Foreach shape
//	for (i in 0...shapes.length) {
//		var shape = shapes.members[i];
//
//		// Calculate the scores for swapping with every other shape
//		for (j in 0...shapes.length) {
//			var other = shapes.members[j];
//
//			var currentScore:Float = CostFunctions.calculateScore(shape.startData, shape.endData) + CostFunctions.calculateScore(other.startData, other.endData);
//			var swappedScore:Float = CostFunctions.calculateScore(shape.startData, other.endData) + CostFunctions.calculateScore(shape.endData, other.startData);
//
//			var improvement:Float = currentScore - swappedScore;
//
//			var current = results.get(shape);
//			if (current == null) {
//				results.set(shape, [{ index: j, improvement: improvement }]);
//			} else {
//				current.push({ index: j, improvement: improvement });
//			}
//		}
//	}
//
//	var keys = results.keys();
//
//	var usedIndices = [];
//	for (key in keys) {
//		var shape = key;
//		var arr = results.get(key);
//		arr.sort(function(a, b) {
//			if (a.improvement > b.improvement) {
//				return 1;
//			}
//			return -1;
//		});
//
//		var idx = 0;
//		var bestIndex:Int = arr[idx].index;
//		while (Lambda.has(usedIndices, bestIndex)) {
//			bestIndex = arr[idx++].index;
//		}
//		usedIndices.push(bestIndex);
//		swap(shape, shapes.members[bestIndex]);
//	}
//}